/*
 * phase4.c
 *
 * This file contains the implementation of Phase 4 of the CS 452 project.
 * It includes the device drivers for the clock, terminal, and disk devices,
 * as well as the necessary system calls for interacting with these devices.
 *
 * The clock device driver implements the Sleep() system call, allowing processes
 * to sleep for a specified number of seconds. The terminal device driver handles
 * the reading and writing of characters to and from the terminal units. The disk
 * device driver provides functionality for reading and writing to the disk, as well
 * as querying the disk size.
 *
 * The file also contains various helper functions and data structures used by the
 * device drivers and system calls. These include functions for locking and unlocking
 * mailboxes, as well as structures for managing sleeping processes.
 *
 * Author: Ishika Patel & Hamad Marhoon
 */

#include <stdio.h>
#include <phase1.h>
#include <phase2.h>
#include <phase3.h>
#include <phase4.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>

typedef struct SleepProc
{
    int pid;
    int wakeupTime;
    struct SleepProc *next;
} SleepProc;

typedef struct DiskRequest DiskRequest;

struct DiskRequest
{
    int operation; // operation to be performed
    int track; // disk track operation is to be performed
    DiskRequest *next;
};

typedef struct Disk
{
    USLOSS_DeviceRequest request;
    int unit;
    int tracks; // total number of tracks on the disk
    int track_size; // size of each track on the disk
    int current_track; // current track position of the disk head
    int sector_size; // size of each sector on the disk
    int disk_size; // total size of the disk, often calculated as tracks * track_size
    int status; // current status of the disk, used to manage error states and operation results
    DiskRequest *requestQueue; // head of a linked list of disk requests, managing pending operations in a queue
} Disk;

Disk disks[USLOSS_DISK_UNITS];

int clock_ticks = 0;        // amount of clock ticks that have occurred
int sleep_lock;             // lock for sleep handler
int totalSleepingProcs = 0; // total number of sleeping procs in queue

SleepProc sleepTable[MAXPROC]; // memory for processes created
SleepProc *sleepQueue = NULL;  // queue for waking up sleeping procs

int diskLocks[USLOSS_DISK_UNITS];          // lock for each of 2 disk devices
int diskRequestMboxIDs[USLOSS_DISK_UNITS]; // holds mailbox ids for disk requests

int termWriteLocks[USLOSS_TERM_UNITS];      // write lock for each of 4 terminal devices
int writeRequestMboxIDs[USLOSS_TERM_UNITS]; // holds mailbox ids for terminal write requests

int readBuffersMbox[USLOSS_TERM_UNITS]; // mailbox id for 10 buffers for each unit

void lock(int lockId);
void unlock(int lockId);
int clockDeviceDriver(char *arg);
int TerminalDeviceDriver(char *arg);
void sleepHandler(USLOSS_Sysargs *sysargs);
void termReadHandler(USLOSS_Sysargs *sysargs);
void termWriteHandler(USLOSS_Sysargs *sysargs);
void diskReadHandler(USLOSS_Sysargs *sysargs);
void diskWriteHandler(USLOSS_Sysargs *sysargs);
void diskSizeHandler(USLOSS_Sysargs *sysargs);

/*
 * Initializes the phase 4 data structures and sets up the necessary mailboxes and locks
 * It also initializes the system call vectors for sleep, terminal read, terminal write handlers, disk
 * size handler, disk read handler, and disk write handler.
 * Additionally, it enables interrupts for the terminal units
 *
 * Returns: void
 */
void phase4_init(void)
{
    memset(sleepTable, 0, sizeof(sleepTable));

    systemCallVec[SYS_SLEEP] = sleepHandler;
    systemCallVec[SYS_TERMREAD] = termReadHandler;
    systemCallVec[SYS_TERMWRITE] = termWriteHandler;
    systemCallVec[SYS_DISKSIZE] = diskSizeHandler;
    systemCallVec[SYS_DISKREAD] = diskReadHandler;
    systemCallVec[SYS_DISKWRITE] = diskWriteHandler;

    // for sleep
    sleep_lock = MboxCreate(1, 0);

    // for disk
    for (int i = 0; i < USLOSS_DISK_UNITS; i++)
    {
        disks[i].unit = i;
        disks[i].tracks = 0;
        disks[i].track_size = 0;
        disks[i].sector_size = 0;
        disks[i].disk_size = 0;
        disks[i].status = 0;
        disks[i].request.opr = -1;
        disks[i].request.reg1 = (void *)(long)-1;
        disks[i].request.reg2 = (void *)(long)-1;
        disks[i].current_track = -1;
        diskLocks[i] = MboxCreate(1, 0);
        diskRequestMboxIDs[i] = MboxCreate(1, 0);
    }

    // for terminal
    for (int i = 0; i < USLOSS_TERM_UNITS; i++)
    {
        termWriteLocks[i] = MboxCreate(1, 0);
        writeRequestMboxIDs[i] = MboxCreate(0, 0);
        readBuffersMbox[i] = MboxCreate(10, MAXLINE);
    }

    // enabling interrupts for terminal units
    int control = 0;
    control = USLOSS_TERM_CTRL_XMIT_INT(control);
    control = USLOSS_TERM_CTRL_RECV_INT(control);

    USLOSS_DeviceOutput(USLOSS_TERM_DEV, 0, (void *)(long)control);
    USLOSS_DeviceOutput(USLOSS_TERM_DEV, 1, (void *)(long)control);
    USLOSS_DeviceOutput(USLOSS_TERM_DEV, 2, (void *)(long)control);
    USLOSS_DeviceOutput(USLOSS_TERM_DEV, 3, (void *)(long)control);
}

/**
 * DiskDeviceDriver runs continuously to handle disk operations for a specified disk unit. 
 * It continually monitoring the disk's status and notifys the system when the disk is 
 * ready to process a new request.
 *
 * @param arg string that determines which disk unit (0 or 1) the driver should manage.
 *
 * @return always returns 0
 */
int DiskDeviceDriver(char *arg)
{
    int unit;
    int status1; // status from waitDevice
    int status2; // status from disk driver after polling

    if (strcmp(arg, "0") == 0)
    {
        unit = 0;
    }
    else if (strcmp(arg, "1") == 0)
    {
        unit = 1;
    }

    while (1)
    {
        waitDevice(USLOSS_DISK_DEV, unit, &status1);

        USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status2);

        // checks if the disk device is ready to handle another request
        if (status2 == USLOSS_DEV_READY)
        {
            MboxCondSend(diskRequestMboxIDs[unit], NULL, 0);
        }
    }

    return 0;
}

/**
 * Inserts a new disk request into the disk's request queue in sorted order based on track numbers.
 * This function maintains an ordered queue which is used to optimize disk head movement,
 * minimizing seek times by ordering requests closest to the current disk head position.
 *
 * @param disk pointer to the Disk structure representing the disk for which the request is intended.
 * @param request pointer to the DiskRequest structure that needs to be added to the disk's queue.
 */
void insertDiskRequest(Disk *disk, DiskRequest *request)
{
    DiskRequest *prev = NULL;
    DiskRequest *current = disk->requestQueue;

    // interate through the queue and find next position to insert for new request
    while (current != NULL && current->track <= request->track)
    {
        prev = current;
        current = current->next;
    }

    if (prev == NULL)
    {
        request->next = disk->requestQueue;
        disk->requestQueue = request;
    }
    else
    {
        request->next = prev->next;
        prev->next = request;
    }
    //printf("Queue after adding request for track %d:\n", request->track);
    //printDiskQueue(disk);
}

/*
    The function printDiskQueue, commented out, was used for debugging. 
*/

// void printDiskQueue(Disk *disk)
// {
//     DiskRequest *current = disk->requestQueue;

//     if (current == NULL)
//     {
//         printf("Queue is empty.\n");
//         return;
//     }

//     while (current != NULL)
//     {
//         printf("Track: %d\n", current->track);
//         current = current->next;
//     }
//     printf("\n");
// }


/**
 * This function gets size details of a specific disk unit. It updates the sector size, track size,
 *  and calculates the total disk size based on these details.
 *
 * @param unit disk unit index for which size details are required.
 * @param sector pointer to an integer where the sector size of the disk will be stored.
 * @param track pointer to an integer where the track size of the disk will be stored.
 * @param disk pointer to an integer where the total size of the disk (in terms of track count) will be stored.
 *
 * @return always returns 0
 */
int kernDiskSize(int unit, int *sector, int *track, int *disk)
{
    lock(diskLocks[unit]);

    // settig up disk requests 
    disks[unit].request.opr = USLOSS_DISK_TRACKS;
    disks[unit].request.reg1 = &disks[unit].tracks;

    USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
    MboxRecv(diskRequestMboxIDs[unit], NULL, 0);

    // setting known values 
    disks[unit].sector_size = USLOSS_DISK_SECTOR_SIZE;
    disks[unit].track_size = USLOSS_DISK_TRACK_SIZE;
    disks[unit].disk_size = disks[unit].tracks;

    *sector = disks[unit].sector_size;
    *track = disks[unit].track_size;
    *disk = disks[unit].disk_size;

    unlock(diskLocks[unit]);

    return 0;
}

/**
 * This function is the system call handler for retrieving the size of a disk unit. This function uses USLOSS_Sysargs
 * to communicate between user programs and OS. It extracts the disk unit number from system
 * call arguments, queries the size of the disk, and returns the results back to the caller through
 * the same structure.
 *
 * @param sysargs pointer to USLOSS_Sysargs structure containing system call arguments
 */
void diskSizeHandler(USLOSS_Sysargs *sysargs)
{
    int unit = (int)(long)sysargs->arg1;
    int sector, track, disk;

    int result = kernDiskSize(unit, &sector, &track, &disk);

    sysargs->arg1 = (void *)(long)sector;
    sysargs->arg2 = (void *)(long)track;
    sysargs->arg3 = (void *)(long)disk;
    sysargs->arg4 = (void *)(long)result;
}

/**
 * This function is the system call handler for writing data to a disk. It manages the extraction of parameters
 * from the USLOSS_Sysargs structure, validates the input parameters, and proceeds to perform
 * the disk write operation.
 *
 * @param sysargs pointer to USLOSS_Sysargs structure containing system call arguments
 */
void diskWriteHandler(USLOSS_Sysargs *sysargs)
{
    char *buffer = (char *)sysargs->arg1;
    int sectors = (int)(long)sysargs->arg2;
    int track = (int)(long)sysargs->arg3;
    int initial_block = (int)(long)sysargs->arg4;
    int unit = (int)(long)sysargs->arg5;
    int status = 0;

    if (unit < 0 || unit >= USLOSS_DISK_UNITS)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }
    if (buffer == NULL || sectors <= 0)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }
    if (track < 0)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = -1;
        return;
    }
    if (initial_block < 0 || initial_block > USLOSS_DISK_TRACK_SIZE)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }

    DiskRequest request;
    request.operation = USLOSS_DISK_WRITE;
    request.track = track;
    //insertDiskRequest(&disks[unit], &request);

    // perform the disk write operation.
    int res = kernDiskWrite(buffer, sectors, track, initial_block, unit, &status);
    if (res == USLOSS_DEV_ERROR)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)0;
        return;
    }

    sysargs->arg1 = (void *)(long)status;
    sysargs->arg4 = (void *)(long)res;
}

/**
 * This function performs a write operation to a disk at a specified track and block. This function handles
 * low-level disk interactions.
 *
 * @param buffer pointer to the data buffer that contains the information to be written to the disk.
 * @param sectors number of sectors to write.
 * @param track track number on which to start writing.
 * @param initial_block sector number within the track to start writing from.
 * @param unit disk unit on which the operation is to be performed.
 * @param status pointer to an integer where the status of the operation will be stored.
 *
 * @return returns 0 on success, and USLOSS_DEV_ERROR on failure
 */
int kernDiskWrite(void *buffer, int sectors, int track, int initial_block, int unit, int *status)
{
    lock(diskLocks[unit]);

     // request number of tracks on the disk to verify that the requested track is within bounds
    disks[unit].request.opr = USLOSS_DISK_TRACKS;
    disks[unit].request.reg1 = &disks[unit].tracks;
    USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
    MboxRecv(diskRequestMboxIDs[unit], NULL, 0);

    if (track >= disks[unit].tracks)
    {
        unlock(diskLocks[unit]);
        return USLOSS_DEV_ERROR;
    }

     // set disk head to the correct track
    disks[unit].request.opr = USLOSS_DISK_SEEK;
    disks[unit].request.reg1 = (void *)(long)track;

    USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
    MboxRecv(diskRequestMboxIDs[unit], NULL, 0);

    int numCharsWritten = 0;
    for (int i = initial_block; i < initial_block + sectors; i++)
    {
        int current_track = track + i / USLOSS_DISK_TRACK_SIZE;
        int current_block = i % USLOSS_DISK_TRACK_SIZE;

        // move track head if needed
        if (disks[unit].current_track != current_track)
        {
            disks[unit].current_track = current_track;
            disks[unit].request.opr = USLOSS_DISK_SEEK;
            disks[unit].request.reg1 = (void *)(long)disks[unit].current_track;
            USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
            MboxRecv(diskRequestMboxIDs[unit], NULL, 0); // wait for seek to complete
        }

        // write data to disk
        char writeBuffer[USLOSS_DISK_SECTOR_SIZE];
        memcpy(writeBuffer, (char *)buffer + numCharsWritten, USLOSS_DISK_SECTOR_SIZE);
        disks[unit].request.opr = USLOSS_DISK_WRITE;
        disks[unit].request.reg1 = (void *)(long)current_block;
        disks[unit].request.reg2 = writeBuffer;

        USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);

        MboxRecv(diskRequestMboxIDs[unit], NULL, 0); // wait for write to complete

        numCharsWritten += USLOSS_DISK_SECTOR_SIZE;
    }
    USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status);

    unlock(diskLocks[unit]);
    return 0;
}

/*
 * System call handler for the disk read operation.
 *
 * This function is invoked when a process makes a disk read system call. It extracts
 * the necessary arguments from the USLOSS_Sysargs structure and performs validation
 * checks on the input parameters. If the parameters are valid, it calls the kernDiskRead
 * function to perform the actual disk read operation.
 *
 * Parameters:
 *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
 *
 * System Call Arguments:
 *   arg1 - pointer to the memory buffer where the read data will be stored
 *   arg2 - the number of sectors to read
 *   arg3 - the track number from which to start reading
 *   arg4 - the initial block number within the track to start reading from
 *   arg5 - the disk unit number (0 or 1)
 *
 * Returns:
 *   None
 */
void diskReadHandler(USLOSS_Sysargs *sysargs)
{

    char *buffer = (char *)sysargs->arg1;
    int sectors = (int)(long)sysargs->arg2;
    int track = (int)(long)sysargs->arg3;
    int initial_block = (int)(long)sysargs->arg4;
    int unit = (int)(long)sysargs->arg5;
    int status = 0;

    if (unit < 0 || unit >= USLOSS_DISK_UNITS)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }
    if (buffer == NULL || sectors <= 0)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }
    if (track < 0 || track >= USLOSS_DISK_TRACK_SIZE)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = 0;
        return;
    }
    if (initial_block < 0 || initial_block >= USLOSS_DISK_TRACK_SIZE)
    {
        sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
        sysargs->arg4 = (void *)(long)-1;
        return;
    }

    DiskRequest request;
    request.operation = USLOSS_DISK_READ;
    request.track = track;
    //insertDiskRequest(&disks[unit], &request);

    int res = kernDiskRead(buffer, sectors, track, initial_block, unit, &status);

    sysargs->arg1 = (void *)(long)status;
    sysargs->arg4 = (void *)(long)res;
}

/*
 * Reads data from the specified disk unit into the provided buffer.
 *
 * This function reads the requested number of sectors from the specified disk unit,
 * starting at the given track and initial block. It moves the disk head to the appropriate
 * track and reads the data sector by sector into the provided buffer.
 *
 * Parameters:
 *   buffer - pointer to the memory buffer where the read data will be stored
 *   sectors - the number of sectors to read
 *   track - the track number from which to start reading
 *   initial_block - the initial block number within the track to start reading from
 *   unit - the disk unit number (0 or 1)
 *   status - pointer to an integer variable to store the status of the disk operation
 *
 * Returns:
 *   int - 0 on success, -1 on failure
 */
int kernDiskRead(void *buffer, int sectors, int track, int initial_block, int unit, int *status)
{
    if (unit < 0 || unit >= USLOSS_DISK_UNITS || buffer == NULL || sectors <= 0 || track < 0 || track >= USLOSS_DISK_TRACK_SIZE || initial_block < 0 || initial_block >= USLOSS_DISK_TRACK_SIZE)
    {
        return -1;
    }

    lock(diskLocks[unit]);

    disks[unit].request.opr = USLOSS_DISK_SEEK;
    disks[unit].request.reg1 = (void *)(long)track;
    USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
    MboxRecv(diskRequestMboxIDs[unit], NULL, 0);

    char readBuffer[USLOSS_DISK_SECTOR_SIZE];
    int numCharsRead = 0;
    for (int i = initial_block; i < initial_block + sectors; i++)
    {
        int current_track = track + i / USLOSS_DISK_TRACK_SIZE;
        int current_block = i % USLOSS_DISK_TRACK_SIZE;

        // move track head if needed
        if (disks[unit].current_track != current_track)
        {
            disks[unit].current_track = current_track;
            disks[unit].request.opr = USLOSS_DISK_SEEK;
            disks[unit].request.reg1 = (void *)(long)disks[unit].current_track;
            USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
            MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
        }

        disks[unit].request.opr = USLOSS_DISK_READ;
        disks[unit].request.reg1 = (void *)(long)current_block;
        disks[unit].request.reg2 = readBuffer;

        USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);

        MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
        memcpy((char *)buffer + numCharsRead, readBuffer, USLOSS_DISK_SECTOR_SIZE);

        numCharsRead += USLOSS_DISK_SECTOR_SIZE;
    }

    USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status);

    unlock(diskLocks[unit]);

    return 0;
}

/*
 * Starts the phase 4 service processes, including the clock device driver and
 * the terminal device drivers for each of the four terminal units
 * These processes are created using the spork function
 *
 * Returns: void
 */
void phase4_start_service_processes(void)
{
    spork("ClockDeviceDriver", clockDeviceDriver, NULL, USLOSS_MIN_STACK, 1);
    spork("TerminalDeviceDriver0", TerminalDeviceDriver, "0", USLOSS_MIN_STACK, 1);
    spork("TerminalDeviceDriver1", TerminalDeviceDriver, "1", USLOSS_MIN_STACK, 1);
    spork("TerminalDeviceDriver2", TerminalDeviceDriver, "2", USLOSS_MIN_STACK, 1);
    spork("TerminalDeviceDriver3", TerminalDeviceDriver, "3", USLOSS_MIN_STACK, 1);
    spork("DiskDeviceDriver1", DiskDeviceDriver, "0", USLOSS_MIN_STACK, 1);
    spork("DiskDeviceDriver2", DiskDeviceDriver, "1", USLOSS_MIN_STACK, 1);
}

/*
 * Handles the terminal device driver functionality for a specific terminal unit
 * It continuously waits for interrupts from the terminal and processes them accordingly
 * If a character is received, it is added to the buffer and sent to the read mailbox if a newline is encountered or the buffer is full
 * If the terminal is ready for writing, it sends a message to the write request mailbox
 *
 * Parameters:
 *   arg - a string representing the terminal unit number
 *
 * Returns:
 *   int - always returns 0
 */
int TerminalDeviceDriver(char *arg)
{
    int unitID = atoi(arg);
    int status;
    char buff[MAXLINE] = "";
    int length = 0;

    while (1)
    {
        waitDevice(USLOSS_TERM_DEV, unitID, &status);

        // checks if terminal interrupt needs to read a character
        if (USLOSS_TERM_STAT_RECV(status) == USLOSS_DEV_BUSY)
        {

            // get character from status register
            char receivedChar = USLOSS_TERM_STAT_CHAR(status);
            buff[length] = receivedChar;
            length += 1;

            // deliver buffer to kernRead if new line character or buffer size reached limit
            if (receivedChar == '\n' || length == MAXLINE)
            {

                // send buffer to mailbox
                MboxCondSend(readBuffersMbox[unitID], buff, length);
                strcpy(buff, "");
                length = 0;
            }
        }

        // checks if terminal is ready for writing a character
        if (USLOSS_TERM_STAT_XMIT(status) == USLOSS_DEV_READY)
        {
            MboxCondSend(writeRequestMboxIDs[unitID], NULL, 0);
        }
    }

    return 0;
}

/*
 * Reads a line of input from the specified terminal unit and stores it in the provided buffer
 * It retrieves the input from the corresponding read buffer mailbox
 * The function copies the characters from the read buffer to the user-provided buffer, up to the specified buffer size
 * It also sets the number of characters read in the numCharsRead pointer
 *
 * Parameters:
 *   buffer - a character array to store the read input
 *   bufferSize - the size of the provided buffer
 *   unitID - the ID of the terminal unit to read from
 *   numCharsRead - a pointer to an integer to store the number of characters read
 *
 * Returns:
 *   int - returns 0 on success, -1 if invalid parameters are provided
 */
int kernTermRead(char *buffer, int bufferSize, int unitID, int *numCharsRead)
{
    if (unitID < 0 || unitID >= USLOSS_TERM_UNITS || buffer == NULL || bufferSize <= 0)
    {
        return -1;
    }

    char readBuff[MAXLINE + 1];
    *numCharsRead = MboxRecv(readBuffersMbox[unitID], readBuff, MAXLINE);

    // copy only characters up to bufferSize given by user
    memcpy(buffer, readBuff, bufferSize);

    // set number of characters read to bufferSize since we only copied a max of bufferSize characters
    if (*numCharsRead > bufferSize)
    {
        *numCharsRead = bufferSize;
    }
    buffer[*numCharsRead] = '\0';
    return 0;
}

/*
 * Writes the contents of the provided buffer to the specified terminal unit
 * It acquires the write lock for the terminal unit before writing
 * The function iterates through the buffer and writes each character to the terminal
 * It waits for the terminal to be ready for writing before sending each character
 * The number of characters written is stored in the numCharsWritten pointer
 *
 * Parameters:
 *   buffer - a character array containing the data to be written
 *   bufferSize - the size of the provided buffer
 *   unitID - the ID of the terminal unit to write to
 *   numCharsWritten - a pointer to an integer to store the number of characters written
 *
 * Returns:
 *   int - returns 0 on success, -1 if invalid parameters are provided
 */
int kernTermWrite(char *buffer, int bufferSize, int unitID, int *numCharsWritten)
{
    // USLOSS_Console("in kernTermWrite function\n");
    //  invalid input
    if (unitID < 0 || unitID >= USLOSS_TERM_UNITS || buffer == NULL || bufferSize <= 0)
    {
        return -1;
    }

    // USLOSS_Console("beginnging to copy characters to term %d\n", unitID);
    for (int i = 0; i < bufferSize; i++)
    {

        // wait to write
        MboxRecv(writeRequestMboxIDs[unitID], NULL, 0);

        int control = 0x1;
        control |= 0x2;
        control |= 0x4;
        control |= (buffer[i] << 8);

        if (USLOSS_DeviceOutput(USLOSS_TERM_DEV, unitID, (void *)(long)control) != USLOSS_DEV_OK)
        {
            return -1;
        }
        *numCharsWritten += 1;
    }
    return 0;
}

/*
 * System call handler for the terminal read operation
 * It extracts the necessary arguments from the USLOSS_Sysargs structure
 * and calls the kernTermRead function with the provided arguments
 * The result of the kernTermRead function is stored back in the USLOSS_Sysargs structure
 *
 * Parameters:
 *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
 *
 * Returns:
 *   void
 */
void termReadHandler(USLOSS_Sysargs *sysargs)
{
    char *buffer = (char *)sysargs->arg1;
    int bufferSize = (int)(long)sysargs->arg2;
    int unitID = (int)(long)sysargs->arg3;
    int numCharsRead = 0;

    int res = kernTermRead(buffer, bufferSize, unitID, &numCharsRead);

    sysargs->arg2 = (void *)(long)numCharsRead;
    sysargs->arg4 = (void *)(long)res;
}

/*
 * System call handler for the terminal write operation
 * It extracts the necessary arguments from the USLOSS_Sysargs structure
 * and calls the kernTermWrite function with the provided arguments
 * The result of the kernTermWrite function is stored back in the USLOSS_Sysargs structure
 *
 * Parameters:
 *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
 *
 * Returns:
 *   void
 */
void termWriteHandler(USLOSS_Sysargs *sysargs)
{

    char *buffer = (char *)sysargs->arg1;
    int bufferSize = (int)(long)sysargs->arg2;
    int unitID = (int)(long)sysargs->arg3;
    int numCharsWritten = 0;

    // USLOSS_Console("acquiring lock kernTermWrite for unit %d\n", unitID);
    lock(termWriteLocks[unitID]);
    int res = kernTermWrite(buffer, bufferSize, unitID, &numCharsWritten);
    // USLOSS_Console("releading lock kernTermWritefor unit %d\n", unitID);
    unlock(termWriteLocks[unitID]);

    sysargs->arg2 = (void *)(long)numCharsWritten;
    sysargs->arg4 = (void *)(long)res;
}

/*
 * System call handler for the sleep operation
 * It extracts the necessary arguments from the USLOSS_Sysargs structure
 * and calls the kernSleep function with the provided arguments
 * The result of the kernSleep function is stored back in the USLOSS_Sysargs structure
 *
 * Parameters:
 *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
 *
 * Returns:
 *   void
 */
void sleepHandler(USLOSS_Sysargs *sysargs)
{
    int seconds = (int)(long)sysargs->arg1;

    int res = kernSleep(seconds);

    sysargs->arg4 = (void *)(long)res;
}

/*
 * Handles the clock device driver functionality
 * It continuously waits for interrupts from the clock device
 * Upon receiving an interrupt, it increments the clock_ticks counter
 * and checks the sleep queue to wake up any processes whose sleep time has expired
 * The function acquires and releases the sleep_lock to ensure thread safety
 *
 * Parameters:
 *   arg - unused parameter, provided for consistency with other device driver functions
 *
 * Returns:
 *   int - always returns 0
 */
int clockDeviceDriver(char *arg)
{
    int status;
    while (1)
    {
        waitDevice(USLOSS_CLOCK_DEV, 0, &status);

        lock(sleep_lock);
        clock_ticks++;
        printf("Clock ticks: %d\n", clock_ticks);

        // iterating through the sleep queue to wake up any processes whose time is up
        while (sleepQueue != NULL && sleepQueue->wakeupTime <= clock_ticks)
        {
            SleepProc *toWake = sleepQueue;
            printf("Waking up process %d\n", toWake->pid);
            unblockProc(toWake->pid);
            sleepQueue = sleepQueue->next;
        }

        unlock(sleep_lock);
    }

    return 0;
}

/*
 * Puts the current process to sleep for the specified number of seconds
 * It calculates the wake-up time based on the current clock ticks and the requested sleep duration
 * The function creates a SleepProc structure to store the process information and adds it to the sleep queue
 * It acquires and releases the sleep_lock to ensure thread safety
 * The process is then blocked until it is woken up by the clock device driver
 *
 * Parameters:
 *   seconds - the number of seconds the process should sleep
 *
 * Returns:
 *   int - returns 0 on success, -1 if an invalid sleep duration is provided
 */
int kernSleep(int seconds)
{
    lock(sleep_lock);

    // invalid argument
    if (seconds < 0)
    {
        return -1;
    }

    int wakeup_tick = clock_ticks + (seconds * 10);
    int cur_pid = getpid();
    printf("Process %d going to sleep for %d seconds\n", cur_pid, seconds);
    printf("Wakeup time: %d\n", wakeup_tick);

    // save data into struct
    SleepProc *request = &sleepTable[cur_pid % MAXPROC];
    request->pid = cur_pid;
    request->wakeupTime = wakeup_tick;
    request->next = NULL;

    // add struct to sleep queue
    if (sleepQueue == NULL)
    {
        sleepQueue = request;
    }
    else
    {

        // finds the next place to insert process in the sleep queue
        SleepProc *prev = NULL;
        SleepProc *current = sleepQueue;
        while (current != NULL && current->wakeupTime <= request->wakeupTime)
        {
            prev = current;
            current = current->next;
        }
        if (prev == NULL)
        {
            request->next = sleepQueue;
            sleepQueue = request;
        }
        else
        {
            request->next = prev->next;
            prev->next = request;
        }
    }

    totalSleepingProcs++;

    unlock(sleep_lock);
    blockMe();

    return 0;
}

/**
 * Locks a mailbox acting as a mutex.
 *
 * @param lockId The mailbox ID to be locked.
 */
void lock(int lockId)
{
    MboxSend(lockId, NULL, 0);
}

/**
 * Unlocks a mailbox acting as a mutex.
 *
 * @param lockId The mailbox ID to be unlocked.
 */
void unlock(int lockId)
{
    MboxRecv(lockId, NULL, 0);
}
