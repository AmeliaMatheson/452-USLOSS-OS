1,20c1,9
< /*
<  * phase4.c
<  *
<  * This file contains the implementation of Phase 4 of the CS 452 project.
<  * It includes the device drivers for the clock, terminal, and disk devices,
<  * as well as the necessary system calls for interacting with these devices.
<  *
<  * The clock device driver implements the Sleep() system call, allowing processes
<  * to sleep for a specified number of seconds. The terminal device driver handles
<  * the reading and writing of characters to and from the terminal units. The disk
<  * device driver provides functionality for reading and writing to the disk, as well
<  * as querying the disk size.
<  *
<  * The file also contains various helper functions and data structures used by the
<  * device drivers and system calls. These include functions for locking and unlocking
<  * mailboxes, as well as structures for managing sleeping processes.
<  *
<  * Author: Ishika Patel & Hamad Marhoon
<  */
< 
---
> #include "phase1.h"
> #include "phase2.h"
> #include "phase3.h"
> #include "phase4.h"
> #include "phase3_usermode.h"
> #include "phase3_kernelInterfaces.h"
> #include "phase4_usermode.h"
> #include <usloss.h>
> #include "usloss.h"
22,26d10
< #include <phase1.h>
< #include <phase2.h>
< #include <phase3.h>
< #include <phase4.h>
< #include <string.h>
28,69c12
< #include <stdint.h>
< 
< typedef struct SleepProc
< {
<     int pid;
<     int wakeupTime;
<     struct SleepProc *next;
< } SleepProc;
< 
< typedef struct DiskRequest DiskRequest;
< 
< struct DiskRequest
< {
<     int operation; // operation to be performed
<     int track; // disk track operation is to be performed
<     DiskRequest *next;
< };
< 
< typedef struct Disk
< {
<     USLOSS_DeviceRequest request;
<     int unit;
<     int tracks; // total number of tracks on the disk
<     int track_size; // size of each track on the disk
<     int current_track; // current track position of the disk head
<     int sector_size; // size of each sector on the disk
<     int disk_size; // total size of the disk, often calculated as tracks * track_size
<     int status; // current status of the disk, used to manage error states and operation results
<     DiskRequest *requestQueue; // head of a linked list of disk requests, managing pending operations in a queue
< } Disk;
< 
< Disk disks[USLOSS_DISK_UNITS];
< 
< int clock_ticks = 0;        // amount of clock ticks that have occurred
< int sleep_lock;             // lock for sleep handler
< int totalSleepingProcs = 0; // total number of sleeping procs in queue
< 
< SleepProc sleepTable[MAXPROC]; // memory for processes created
< SleepProc *sleepQueue = NULL;  // queue for waking up sleeping procs
< 
< int diskLocks[USLOSS_DISK_UNITS];          // lock for each of 2 disk devices
< int diskRequestMboxIDs[USLOSS_DISK_UNITS]; // holds mailbox ids for disk requests
---
> #include <string.h>
71,72c14,17
< int termWriteLocks[USLOSS_TERM_UNITS];      // write lock for each of 4 terminal devices
< int writeRequestMboxIDs[USLOSS_TERM_UNITS]; // holds mailbox ids for terminal write requests
---
> /*
>   Authors: Hudson Cox (majority contribution), Amelia Matheson
>   File: phase4a.c
> */
74c19,30
< int readBuffersMbox[USLOSS_TERM_UNITS]; // mailbox id for 10 buffers for each unit
---
> // Prototypes
> int TerminalDriver(char *arg);
> void sleepSysHandler(USLOSS_Sysargs *args);
> int Kernel_Sleep(int time);
> void termReadSysHandler(USLOSS_Sysargs *args);
> int Kernel_TermRead(char *buffer, int bufferSize, int unitID, int *numCharsRead);
> void termWriteSysHandler(USLOSS_Sysargs *args);
> int Kernel_TermWrite(char *buff, int buffSize, int unit, int *charWrite);
> void Kernel_DiskRead(USLOSS_Sysargs *args);
> void Kernel_DiskWrite(USLOSS_Sysargs *args);
> void Kernel_DiskSize(USLOSS_Sysargs *args);
> int ClockDriver(char *arg);
78,85d33
< int clockDeviceDriver(char *arg);
< int TerminalDeviceDriver(char *arg);
< void sleepHandler(USLOSS_Sysargs *sysargs);
< void termReadHandler(USLOSS_Sysargs *sysargs);
< void termWriteHandler(USLOSS_Sysargs *sysargs);
< void diskReadHandler(USLOSS_Sysargs *sysargs);
< void diskWriteHandler(USLOSS_Sysargs *sysargs);
< void diskSizeHandler(USLOSS_Sysargs *sysargs);
87,107c35,40
< /*
<  * Initializes the phase 4 data structures and sets up the necessary mailboxes and locks
<  * It also initializes the system call vectors for sleep, terminal read, terminal write handlers, disk
<  * size handler, disk read handler, and disk write handler.
<  * Additionally, it enables interrupts for the terminal units
<  *
<  * Returns: void
<  */
< void phase4_init(void)
< {
<     memset(sleepTable, 0, sizeof(sleepTable));
< 
<     systemCallVec[SYS_SLEEP] = sleepHandler;
<     systemCallVec[SYS_TERMREAD] = termReadHandler;
<     systemCallVec[SYS_TERMWRITE] = termWriteHandler;
<     systemCallVec[SYS_DISKSIZE] = diskSizeHandler;
<     systemCallVec[SYS_DISKREAD] = diskReadHandler;
<     systemCallVec[SYS_DISKWRITE] = diskWriteHandler;
< 
<     // for sleep
<     sleep_lock = MboxCreate(1, 0);
---
> // Structs
> typedef struct SleepingProc {
>     int pid;
>     int wakeupTime;
>     struct SleepingProc *next;
> } SleepingProc;
109,123c42,68
<     // for disk
<     for (int i = 0; i < USLOSS_DISK_UNITS; i++)
<     {
<         disks[i].unit = i;
<         disks[i].tracks = 0;
<         disks[i].track_size = 0;
<         disks[i].sector_size = 0;
<         disks[i].disk_size = 0;
<         disks[i].status = 0;
<         disks[i].request.opr = -1;
<         disks[i].request.reg1 = (void *)(long)-1;
<         disks[i].request.reg2 = (void *)(long)-1;
<         disks[i].current_track = -1;
<         diskLocks[i] = MboxCreate(1, 0);
<         diskRequestMboxIDs[i] = MboxCreate(1, 0);
---
> // Global variables
> int clockTicks = 0; 
> int sleepLock;
> 
> // Tables and Queues
> int TermReadBoxes[USLOSS_TERM_UNITS];
> int TermWriteBoxes[USLOSS_TERM_UNITS];
> int TermWriteLocks[USLOSS_TERM_UNITS];
> SleepingProc sleeping[MAXPROC];
> SleepingProc *sleepingQueue = NULL;
> 
> 
> void phase4_init() {
>     systemCallVec[SYS_SLEEP] = (void *) sleepSysHandler;
>     systemCallVec[SYS_TERMREAD] = (void *) termReadSysHandler;
>     systemCallVec[SYS_TERMWRITE] = (void *) termWriteSysHandler;
>     systemCallVec[SYS_DISKREAD] = (void *) Kernel_DiskRead;
>     systemCallVec[SYS_DISKWRITE] = (void *) Kernel_DiskWrite;
>     systemCallVec[SYS_DISKSIZE] = (void *) Kernel_DiskSize;
> 
>     memset(sleeping, 0, sizeof(sleeping));
> 
>     // Create mailboxes read and write mailboxes for each terminal unit. Create a lock for each terminal unit
>     for (int i = 0; i < USLOSS_TERM_UNITS; i++) {
>         TermReadBoxes[i] = MboxCreate(10, MAXLINE);  // create returns maibox id
>         TermWriteBoxes[i] = MboxCreate(0, 0);  
>         TermWriteLocks[i] = MboxCreate(1, 0);
126,132c71,72
<     // for terminal
<     for (int i = 0; i < USLOSS_TERM_UNITS; i++)
<     {
<         termWriteLocks[i] = MboxCreate(1, 0);
<         writeRequestMboxIDs[i] = MboxCreate(0, 0);
<         readBuffersMbox[i] = MboxCreate(10, MAXLINE);
<     }
---
>     // Lock for sleep handler
>     sleepLock = MboxCreate(1, 0);
134c74
<     // enabling interrupts for terminal units
---
>     // Enable interrupts for terminal units
145,158c85,90
< /**
<  * DiskDeviceDriver runs continuously to handle disk operations for a specified disk unit. 
<  * It continually monitoring the disk's status and notifys the system when the disk is 
<  * ready to process a new request.
<  *
<  * @param arg string that determines which disk unit (0 or 1) the driver should manage.
<  *
<  * @return always returns 0
<  */
< int DiskDeviceDriver(char *arg)
< {
<     int unit;
<     int status1; // status from waitDevice
<     int status2; // status from disk driver after polling
---
> void phase4_start_service_processes() {
>     // start terminal device drivers for each unit, will act as a waiting process for interrupts
>     spork("TerminalDriver", TerminalDriver, "0", USLOSS_MIN_STACK, 2);
>     spork("TerminalDriver", TerminalDriver, "1", USLOSS_MIN_STACK, 2);
>     spork("TerminalDriver", TerminalDriver, "2", USLOSS_MIN_STACK, 2);
>     spork("TerminalDriver", TerminalDriver, "3", USLOSS_MIN_STACK, 2);
160,180c92
<     if (strcmp(arg, "0") == 0)
<     {
<         unit = 0;
<     }
<     else if (strcmp(arg, "1") == 0)
<     {
<         unit = 1;
<     }
< 
<     while (1)
<     {
<         waitDevice(USLOSS_DISK_DEV, unit, &status1);
< 
<         USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status2);
< 
<         // checks if the disk device is ready to handle another request
<         if (status2 == USLOSS_DEV_READY)
<         {
<             MboxCondSend(diskRequestMboxIDs[unit], NULL, 0);
<         }
<     }
---
>     spork("ClockDriver", ClockDriver, NULL, USLOSS_MIN_STACK, 1);
182d93
<     return 0;
185,196c96,107
< /**
<  * Inserts a new disk request into the disk's request queue in sorted order based on track numbers.
<  * This function maintains an ordered queue which is used to optimize disk head movement,
<  * minimizing seek times by ordering requests closest to the current disk head position.
<  *
<  * @param disk pointer to the Disk structure representing the disk for which the request is intended.
<  * @param request pointer to the DiskRequest structure that needs to be added to the disk's queue.
<  */
< void insertDiskRequest(Disk *disk, DiskRequest *request)
< {
<     DiskRequest *prev = NULL;
<     DiskRequest *current = disk->requestQueue;
---
> int TerminalDriver(char *arg) {
>     printf("TerminalDriver\n");
>     int unit = atoi(arg);
>     int status;
>     
>     char buffer[MAXLINE] = "";
>     int count = 0;
> 
>     // Infinite loop to handle terminal interrupts
>     while (1) {
>         // Call wait device for this terminal unit
>         waitDevice(USLOSS_TERM_DEV, unit, &status);
198,203c109,124
<     // interate through the queue and find next position to insert for new request
<     while (current != NULL && current->track <= request->track)
<     {
<         prev = current;
<         current = current->next;
<     }
---
>         // Check if the terminal is ready to read
>         if (USLOSS_TERM_STAT_RECV(status) == USLOSS_DEV_BUSY) {
>             char receivedChar = USLOSS_TERM_STAT_CHAR(status);
>             buffer[count] = receivedChar;
>             count++;
>             //printf("Received char: %c\n", receivedChar);
>             //printf("Buffer: %s\n", buffer);
> 
>             // Send buffer if encounter newline or buffer is full. Reset buffer and count
>             if (receivedChar == '\n' || count == MAXLINE) {
>                 //printf("\tSending buffer to mailbox\n");
>                 MboxCondSend(TermReadBoxes[unit], buffer, count);
>                 strcpy(buffer, "");
>                 count = 0;
>             }
>         }
205,213c126,131
<     if (prev == NULL)
<     {
<         request->next = disk->requestQueue;
<         disk->requestQueue = request;
<     }
<     else
<     {
<         request->next = prev->next;
<         prev->next = request;
---
>         // Check if the terminal is ready to write
>         if (USLOSS_TERM_STAT_XMIT(status) == USLOSS_DEV_READY) {
>             // Send a message to the write request mailbox
>             printf("\tSending to unit %d\n", unit);
>             MboxCondSend(TermWriteBoxes[unit], NULL, 0);
>         }
215,274d132
<     //printf("Queue after adding request for track %d:\n", request->track);
<     //printDiskQueue(disk);
< }
< 
< /*
<     The function printDiskQueue, commented out, was used for debugging. 
< */
< 
< // void printDiskQueue(Disk *disk)
< // {
< //     DiskRequest *current = disk->requestQueue;
< 
< //     if (current == NULL)
< //     {
< //         printf("Queue is empty.\n");
< //         return;
< //     }
< 
< //     while (current != NULL)
< //     {
< //         printf("Track: %d\n", current->track);
< //         current = current->next;
< //     }
< //     printf("\n");
< // }
< 
< 
< /**
<  * This function gets size details of a specific disk unit. It updates the sector size, track size,
<  *  and calculates the total disk size based on these details.
<  *
<  * @param unit disk unit index for which size details are required.
<  * @param sector pointer to an integer where the sector size of the disk will be stored.
<  * @param track pointer to an integer where the track size of the disk will be stored.
<  * @param disk pointer to an integer where the total size of the disk (in terms of track count) will be stored.
<  *
<  * @return always returns 0
<  */
< int kernDiskSize(int unit, int *sector, int *track, int *disk)
< {
<     lock(diskLocks[unit]);
< 
<     // settig up disk requests 
<     disks[unit].request.opr = USLOSS_DISK_TRACKS;
<     disks[unit].request.reg1 = &disks[unit].tracks;
< 
<     USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<     MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
< 
<     // setting known values 
<     disks[unit].sector_size = USLOSS_DISK_SECTOR_SIZE;
<     disks[unit].track_size = USLOSS_DISK_TRACK_SIZE;
<     disks[unit].disk_size = disks[unit].tracks;
< 
<     *sector = disks[unit].sector_size;
<     *track = disks[unit].track_size;
<     *disk = disks[unit].disk_size;
< 
<     unlock(diskLocks[unit]);
< 
278,306c136
< /**
<  * This function is the system call handler for retrieving the size of a disk unit. This function uses USLOSS_Sysargs
<  * to communicate between user programs and OS. It extracts the disk unit number from system
<  * call arguments, queries the size of the disk, and returns the results back to the caller through
<  * the same structure.
<  *
<  * @param sysargs pointer to USLOSS_Sysargs structure containing system call arguments
<  */
< void diskSizeHandler(USLOSS_Sysargs *sysargs)
< {
<     int unit = (int)(long)sysargs->arg1;
<     int sector, track, disk;
< 
<     int result = kernDiskSize(unit, &sector, &track, &disk);
< 
<     sysargs->arg1 = (void *)(long)sector;
<     sysargs->arg2 = (void *)(long)track;
<     sysargs->arg3 = (void *)(long)disk;
<     sysargs->arg4 = (void *)(long)result;
< }
< 
< /**
<  * This function is the system call handler for writing data to a disk. It manages the extraction of parameters
<  * from the USLOSS_Sysargs structure, validates the input parameters, and proceeds to perform
<  * the disk write operation.
<  *
<  * @param sysargs pointer to USLOSS_Sysargs structure containing system call arguments
<  */
< void diskWriteHandler(USLOSS_Sysargs *sysargs)
---
> int ClockDriver(char *arg)
308,381c138,139
<     char *buffer = (char *)sysargs->arg1;
<     int sectors = (int)(long)sysargs->arg2;
<     int track = (int)(long)sysargs->arg3;
<     int initial_block = (int)(long)sysargs->arg4;
<     int unit = (int)(long)sysargs->arg5;
<     int status = 0;
< 
<     if (unit < 0 || unit >= USLOSS_DISK_UNITS)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
<     if (buffer == NULL || sectors <= 0)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
<     if (track < 0)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = -1;
<         return;
<     }
<     if (initial_block < 0 || initial_block > USLOSS_DISK_TRACK_SIZE)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
< 
<     DiskRequest request;
<     request.operation = USLOSS_DISK_WRITE;
<     request.track = track;
<     //insertDiskRequest(&disks[unit], &request);
< 
<     // perform the disk write operation.
<     int res = kernDiskWrite(buffer, sectors, track, initial_block, unit, &status);
<     if (res == USLOSS_DEV_ERROR)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)0;
<         return;
<     }
< 
<     sysargs->arg1 = (void *)(long)status;
<     sysargs->arg4 = (void *)(long)res;
< }
< 
< /**
<  * This function performs a write operation to a disk at a specified track and block. This function handles
<  * low-level disk interactions.
<  *
<  * @param buffer pointer to the data buffer that contains the information to be written to the disk.
<  * @param sectors number of sectors to write.
<  * @param track track number on which to start writing.
<  * @param initial_block sector number within the track to start writing from.
<  * @param unit disk unit on which the operation is to be performed.
<  * @param status pointer to an integer where the status of the operation will be stored.
<  *
<  * @return returns 0 on success, and USLOSS_DEV_ERROR on failure
<  */
< int kernDiskWrite(void *buffer, int sectors, int track, int initial_block, int unit, int *status)
< {
<     lock(diskLocks[unit]);
< 
<      // request number of tracks on the disk to verify that the requested track is within bounds
<     disks[unit].request.opr = USLOSS_DISK_TRACKS;
<     disks[unit].request.reg1 = &disks[unit].tracks;
<     USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<     MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
< 
<     if (track >= disks[unit].tracks)
---
>     int status;
>     while (1)
383,392c141
<         unlock(diskLocks[unit]);
<         return USLOSS_DEV_ERROR;
<     }
< 
<      // set disk head to the correct track
<     disks[unit].request.opr = USLOSS_DISK_SEEK;
<     disks[unit].request.reg1 = (void *)(long)track;
< 
<     USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<     MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
---
>         waitDevice(USLOSS_CLOCK_DEV, 0, &status);
394,398c143,145
<     int numCharsWritten = 0;
<     for (int i = initial_block; i < initial_block + sectors; i++)
<     {
<         int current_track = track + i / USLOSS_DISK_TRACK_SIZE;
<         int current_block = i % USLOSS_DISK_TRACK_SIZE;
---
>         lock(sleepLock);
>         clockTicks++;
> 	    //printf("clock ticks: %d\n", clockTicks);
400,407c147,151
<         // move track head if needed
<         if (disks[unit].current_track != current_track)
<         {
<             disks[unit].current_track = current_track;
<             disks[unit].request.opr = USLOSS_DISK_SEEK;
<             disks[unit].request.reg1 = (void *)(long)disks[unit].current_track;
<             USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<             MboxRecv(diskRequestMboxIDs[unit], NULL, 0); // wait for seek to complete
---
>         // iterating through the sleep queue to wake up any processes whose time is up
>         while (sleepingQueue != NULL && sleepingQueue->wakeupTime <= clockTicks) {
>             SleepingProc *toWake = sleepingQueue;
>             unblockProc(toWake->pid);
>             sleepingQueue = sleepingQueue->next;
410,421c154
<         // write data to disk
<         char writeBuffer[USLOSS_DISK_SECTOR_SIZE];
<         memcpy(writeBuffer, (char *)buffer + numCharsWritten, USLOSS_DISK_SECTOR_SIZE);
<         disks[unit].request.opr = USLOSS_DISK_WRITE;
<         disks[unit].request.reg1 = (void *)(long)current_block;
<         disks[unit].request.reg2 = writeBuffer;
< 
<         USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
< 
<         MboxRecv(diskRequestMboxIDs[unit], NULL, 0); // wait for write to complete
< 
<         numCharsWritten += USLOSS_DISK_SECTOR_SIZE;
---
>         unlock(sleepLock);
423d155
<     USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status);
425d156
<     unlock(diskLocks[unit]);
429,517c160,175
< /*
<  * System call handler for the disk read operation.
<  *
<  * This function is invoked when a process makes a disk read system call. It extracts
<  * the necessary arguments from the USLOSS_Sysargs structure and performs validation
<  * checks on the input parameters. If the parameters are valid, it calls the kernDiskRead
<  * function to perform the actual disk read operation.
<  *
<  * Parameters:
<  *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
<  *
<  * System Call Arguments:
<  *   arg1 - pointer to the memory buffer where the read data will be stored
<  *   arg2 - the number of sectors to read
<  *   arg3 - the track number from which to start reading
<  *   arg4 - the initial block number within the track to start reading from
<  *   arg5 - the disk unit number (0 or 1)
<  *
<  * Returns:
<  *   None
<  */
< void diskReadHandler(USLOSS_Sysargs *sysargs)
< {
< 
<     char *buffer = (char *)sysargs->arg1;
<     int sectors = (int)(long)sysargs->arg2;
<     int track = (int)(long)sysargs->arg3;
<     int initial_block = (int)(long)sysargs->arg4;
<     int unit = (int)(long)sysargs->arg5;
<     int status = 0;
< 
<     if (unit < 0 || unit >= USLOSS_DISK_UNITS)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
<     if (buffer == NULL || sectors <= 0)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
<     if (track < 0 || track >= USLOSS_DISK_TRACK_SIZE)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = 0;
<         return;
<     }
<     if (initial_block < 0 || initial_block >= USLOSS_DISK_TRACK_SIZE)
<     {
<         sysargs->arg1 = (void *)(long)USLOSS_DEV_ERROR;
<         sysargs->arg4 = (void *)(long)-1;
<         return;
<     }
< 
<     DiskRequest request;
<     request.operation = USLOSS_DISK_READ;
<     request.track = track;
<     //insertDiskRequest(&disks[unit], &request);
< 
<     int res = kernDiskRead(buffer, sectors, track, initial_block, unit, &status);
< 
<     sysargs->arg1 = (void *)(long)status;
<     sysargs->arg4 = (void *)(long)res;
< }
< 
< /*
<  * Reads data from the specified disk unit into the provided buffer.
<  *
<  * This function reads the requested number of sectors from the specified disk unit,
<  * starting at the given track and initial block. It moves the disk head to the appropriate
<  * track and reads the data sector by sector into the provided buffer.
<  *
<  * Parameters:
<  *   buffer - pointer to the memory buffer where the read data will be stored
<  *   sectors - the number of sectors to read
<  *   track - the track number from which to start reading
<  *   initial_block - the initial block number within the track to start reading from
<  *   unit - the disk unit number (0 or 1)
<  *   status - pointer to an integer variable to store the status of the disk operation
<  *
<  * Returns:
<  *   int - 0 on success, -1 on failure
<  */
< int kernDiskRead(void *buffer, int sectors, int track, int initial_block, int unit, int *status)
< {
<     if (unit < 0 || unit >= USLOSS_DISK_UNITS || buffer == NULL || sectors <= 0 || track < 0 || track >= USLOSS_DISK_TRACK_SIZE || initial_block < 0 || initial_block >= USLOSS_DISK_TRACK_SIZE)
<     {
---
> void sleepSysHandler(USLOSS_Sysargs *args) {
>     
>     // Extract arguments
>     int sec = (int)(long)args->arg1;
>     //printf("\tinfo from args: %d\n", sec);
>     
>     // Call Kernel_sleep
>     int sysStat = Kernel_Sleep(sec);
>     args->arg4 = (void *)(long)sysStat;
> }
> 
> int Kernel_Sleep(int time) {
>     // make sure we are in kernel mode
>     
>     lock(sleepLock);
>     if (time < 0) {
521,557c179
<     lock(diskLocks[unit]);
< 
<     disks[unit].request.opr = USLOSS_DISK_SEEK;
<     disks[unit].request.reg1 = (void *)(long)track;
<     USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<     MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
< 
<     char readBuffer[USLOSS_DISK_SECTOR_SIZE];
<     int numCharsRead = 0;
<     for (int i = initial_block; i < initial_block + sectors; i++)
<     {
<         int current_track = track + i / USLOSS_DISK_TRACK_SIZE;
<         int current_block = i % USLOSS_DISK_TRACK_SIZE;
< 
<         // move track head if needed
<         if (disks[unit].current_track != current_track)
<         {
<             disks[unit].current_track = current_track;
<             disks[unit].request.opr = USLOSS_DISK_SEEK;
<             disks[unit].request.reg1 = (void *)(long)disks[unit].current_track;
<             USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
<             MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
<         }
< 
<         disks[unit].request.opr = USLOSS_DISK_READ;
<         disks[unit].request.reg1 = (void *)(long)current_block;
<         disks[unit].request.reg2 = readBuffer;
< 
<         USLOSS_DeviceOutput(USLOSS_DISK_DEV, unit, &disks[unit].request);
< 
<         MboxRecv(diskRequestMboxIDs[unit], NULL, 0);
<         memcpy((char *)buffer + numCharsRead, readBuffer, USLOSS_DISK_SECTOR_SIZE);
< 
<         numCharsRead += USLOSS_DISK_SECTOR_SIZE;
<     }
< 
<     USLOSS_DeviceInput(USLOSS_DISK_DEV, unit, &status);
---
>     //printf("Kernel_Sleep, time: %d\n", time);
559,596c181,183
<     unlock(diskLocks[unit]);
< 
<     return 0;
< }
< 
< /*
<  * Starts the phase 4 service processes, including the clock device driver and
<  * the terminal device drivers for each of the four terminal units
<  * These processes are created using the spork function
<  *
<  * Returns: void
<  */
< void phase4_start_service_processes(void)
< {
<     spork("ClockDeviceDriver", clockDeviceDriver, NULL, USLOSS_MIN_STACK, 1);
<     spork("TerminalDeviceDriver0", TerminalDeviceDriver, "0", USLOSS_MIN_STACK, 1);
<     spork("TerminalDeviceDriver1", TerminalDeviceDriver, "1", USLOSS_MIN_STACK, 1);
<     spork("TerminalDeviceDriver2", TerminalDeviceDriver, "2", USLOSS_MIN_STACK, 1);
<     spork("TerminalDeviceDriver3", TerminalDeviceDriver, "3", USLOSS_MIN_STACK, 1);
<     spork("DiskDeviceDriver1", DiskDeviceDriver, "0", USLOSS_MIN_STACK, 1);
<     spork("DiskDeviceDriver2", DiskDeviceDriver, "1", USLOSS_MIN_STACK, 1);
< }
< 
< /*
<  * Handles the terminal device driver functionality for a specific terminal unit
<  * It continuously waits for interrupts from the terminal and processes them accordingly
<  * If a character is received, it is added to the buffer and sent to the read mailbox if a newline is encountered or the buffer is full
<  * If the terminal is ready for writing, it sends a message to the write request mailbox
<  *
<  * Parameters:
<  *   arg - a string representing the terminal unit number
<  *
<  * Returns:
<  *   int - always returns 0
<  */
< int TerminalDeviceDriver(char *arg)
< {
<     int unitID = atoi(arg);
---
>     //int waitTime = (currentTime()/1000) + (time*1000);
>     int waitTime = clockTicks + (time * 10);
>     //printf("waitTime: %d\n", waitTime);
598,612c185
<     char buff[MAXLINE] = "";
<     int length = 0;
< 
<     while (1)
<     {
<         waitDevice(USLOSS_TERM_DEV, unitID, &status);
< 
<         // checks if terminal interrupt needs to read a character
<         if (USLOSS_TERM_STAT_RECV(status) == USLOSS_DEV_BUSY)
<         {
< 
<             // get character from status register
<             char receivedChar = USLOSS_TERM_STAT_CHAR(status);
<             buff[length] = receivedChar;
<             length += 1;
---
>     int pid = getpid();
614,622c187,203
<             // deliver buffer to kernRead if new line character or buffer size reached limit
<             if (receivedChar == '\n' || length == MAXLINE)
<             {
< 
<                 // send buffer to mailbox
<                 MboxCondSend(readBuffersMbox[unitID], buff, length);
<                 strcpy(buff, "");
<                 length = 0;
<             }
---
>     // create new sleeping process
>     SleepingProc *newSleep = &sleeping[pid % MAXPROC];
>     newSleep->pid = pid;
>     newSleep->wakeupTime = waitTime;
>     newSleep->next = NULL;
> 
>     // add to the queue
>     if (sleepingQueue == NULL) {
>         sleepingQueue = newSleep;
>     }
>     else {
>         // finds the next place to insert process in the sleep queue
>         SleepingProc *prev = NULL;
>         SleepingProc *current = sleepingQueue;
>         while (current != NULL && current->wakeupTime <= newSleep->wakeupTime) {
>             prev = current;
>             current = current->next;
624,628c205,211
< 
<         // checks if terminal is ready for writing a character
<         if (USLOSS_TERM_STAT_XMIT(status) == USLOSS_DEV_READY)
<         {
<             MboxCondSend(writeRequestMboxIDs[unitID], NULL, 0);
---
>         if (prev == NULL) {
>             newSleep->next = sleepingQueue;
>             sleepingQueue = newSleep;
>         }
>         else {
>             newSleep->next = prev->next;
>             prev->next = newSleep;
630a214,218
>     
>     // while (currentTime()/1000 < waitTime) {
>     //     waitDevice(0, 0, &status);
>     // }
>     
631a220,221
>     unlock(sleepLock);
>     blockMe();
635,653c225,228
< /*
<  * Reads a line of input from the specified terminal unit and stores it in the provided buffer
<  * It retrieves the input from the corresponding read buffer mailbox
<  * The function copies the characters from the read buffer to the user-provided buffer, up to the specified buffer size
<  * It also sets the number of characters read in the numCharsRead pointer
<  *
<  * Parameters:
<  *   buffer - a character array to store the read input
<  *   bufferSize - the size of the provided buffer
<  *   unitID - the ID of the terminal unit to read from
<  *   numCharsRead - a pointer to an integer to store the number of characters read
<  *
<  * Returns:
<  *   int - returns 0 on success, -1 if invalid parameters are provided
<  */
< int kernTermRead(char *buffer, int bufferSize, int unitID, int *numCharsRead)
< {
<     if (unitID < 0 || unitID >= USLOSS_TERM_UNITS || buffer == NULL || bufferSize <= 0)
<     {
---
> 
> int Kernel_TermRead(char *buffer, int bufferSize, int unitID, int *numCharsRead) {
>     printf("Kerl_TermRead\n");
>     if (unitID < 0 || unitID >= USLOSS_TERM_UNITS || buffer == NULL || bufferSize <= 0) {
657,666c232,240
<     char readBuff[MAXLINE + 1];
<     *numCharsRead = MboxRecv(readBuffersMbox[unitID], readBuff, MAXLINE);
< 
<     // copy only characters up to bufferSize given by user
<     memcpy(buffer, readBuff, bufferSize);
< 
<     // set number of characters read to bufferSize since we only copied a max of bufferSize characters
<     if (*numCharsRead > bufferSize)
<     {
<         *numCharsRead = bufferSize;
---
>     // Expecting that interrupts are being handled in the terminal driver, just need
>     // to grab the characters from the mailbox
>     printf("\tReading from mailbox\n"); 
>     char readin[MAXLINE + 1];
>     *numCharsRead = MboxRecv(TermReadBoxes[unitID], readin, MAXLINE);
>    
>     memcpy(buffer, readin, bufferSize);  // use bufferSize to copy only the number of characters requested
>     if (*numCharsRead > bufferSize) {
>         *numCharsRead = bufferSize;  // only copy the number of characters requested
668c242
<     buffer[*numCharsRead] = '\0';
---
>     buffer[*numCharsRead] = '\0';  // null terminate the string
672,693c246,265
< /*
<  * Writes the contents of the provided buffer to the specified terminal unit
<  * It acquires the write lock for the terminal unit before writing
<  * The function iterates through the buffer and writes each character to the terminal
<  * It waits for the terminal to be ready for writing before sending each character
<  * The number of characters written is stored in the numCharsWritten pointer
<  *
<  * Parameters:
<  *   buffer - a character array containing the data to be written
<  *   bufferSize - the size of the provided buffer
<  *   unitID - the ID of the terminal unit to write to
<  *   numCharsWritten - a pointer to an integer to store the number of characters written
<  *
<  * Returns:
<  *   int - returns 0 on success, -1 if invalid parameters are provided
<  */
< int kernTermWrite(char *buffer, int bufferSize, int unitID, int *numCharsWritten)
< {
<     // USLOSS_Console("in kernTermWrite function\n");
<     //  invalid input
<     if (unitID < 0 || unitID >= USLOSS_TERM_UNITS || buffer == NULL || bufferSize <= 0)
<     {
---
> void termReadSysHandler(USLOSS_Sysargs *args) {
>     printf("term read sys\n");
> 
>     // Extract arguments
>     char* buff = (char *)args->arg1;
>     int buffSize = (int)(long)args->arg2;
>     int unit = (int)(long)args->arg3;
>     //printf("\tinfo from args: %s, %d, %d\n", buff, buffSize, unit);
>     
>     // Grab the characters from the mailbox
>     int charRead = 0;
>     int sysStat = Kernel_TermRead(buff, buffSize, unit, &charRead);
>     
>     // Save the number of characters read in arg2 and the status in arg4
>     args->arg2 = (void *)(long)charRead;
>     args->arg4 = (void *)(long)sysStat;
> }
> 
> int Kernel_TermWrite(char *buff, int buffSize, int unit, int *charWrite) {
>     if (unit < 0 || unit >= USLOSS_TERM_UNITS || buff == NULL || buffSize <= 0) {
697,702c269,270
<     // USLOSS_Console("beginnging to copy characters to term %d\n", unitID);
<     for (int i = 0; i < bufferSize; i++)
<     {
< 
<         // wait to write
<         MboxRecv(writeRequestMboxIDs[unitID], NULL, 0);
---
>     for (int i = 0; i < buffSize; i++) {
>         MboxRecv(TermWriteBoxes[unit], NULL, 0);
707c275
<         control |= (buffer[i] << 8);
---
>         control |= (buff[i] << 8);
709,710c277
<         if (USLOSS_DeviceOutput(USLOSS_TERM_DEV, unitID, (void *)(long)control) != USLOSS_DEV_OK)
<         {
---
>         if (USLOSS_DeviceOutput(USLOSS_TERM_DEV, unit, (void *)(long)control) != USLOSS_DEV_OK) {
713c280
<         *numCharsWritten += 1;
---
>         *charWrite += 1;
718,735d284
< /*
<  * System call handler for the terminal read operation
<  * It extracts the necessary arguments from the USLOSS_Sysargs structure
<  * and calls the kernTermRead function with the provided arguments
<  * The result of the kernTermRead function is stored back in the USLOSS_Sysargs structure
<  *
<  * Parameters:
<  *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
<  *
<  * Returns:
<  *   void
<  */
< void termReadHandler(USLOSS_Sysargs *sysargs)
< {
<     char *buffer = (char *)sysargs->arg1;
<     int bufferSize = (int)(long)sysargs->arg2;
<     int unitID = (int)(long)sysargs->arg3;
<     int numCharsRead = 0;
737d285
<     int res = kernTermRead(buffer, bufferSize, unitID, &numCharsRead);
739,741c287
<     sysargs->arg2 = (void *)(long)numCharsRead;
<     sysargs->arg4 = (void *)(long)res;
< }
---
> void termWriteSysHandler(USLOSS_Sysargs *args) {
743,767d288
< /*
<  * System call handler for the terminal write operation
<  * It extracts the necessary arguments from the USLOSS_Sysargs structure
<  * and calls the kernTermWrite function with the provided arguments
<  * The result of the kernTermWrite function is stored back in the USLOSS_Sysargs structure
<  *
<  * Parameters:
<  *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
<  *
<  * Returns:
<  *   void
<  */
< void termWriteHandler(USLOSS_Sysargs *sysargs)
< {
< 
<     char *buffer = (char *)sysargs->arg1;
<     int bufferSize = (int)(long)sysargs->arg2;
<     int unitID = (int)(long)sysargs->arg3;
<     int numCharsWritten = 0;
< 
<     // USLOSS_Console("acquiring lock kernTermWrite for unit %d\n", unitID);
<     lock(termWriteLocks[unitID]);
<     int res = kernTermWrite(buffer, bufferSize, unitID, &numCharsWritten);
<     // USLOSS_Console("releading lock kernTermWritefor unit %d\n", unitID);
<     unlock(termWriteLocks[unitID]);
769,771c290,293
<     sysargs->arg2 = (void *)(long)numCharsWritten;
<     sysargs->arg4 = (void *)(long)res;
< }
---
>     // Extract arguments
>     char *buff = (char *)args->arg1;
>     int buffSize = (int)(long)args->arg2;
>     int unit = (int)(long)args->arg3;
773,787c295,296
< /*
<  * System call handler for the sleep operation
<  * It extracts the necessary arguments from the USLOSS_Sysargs structure
<  * and calls the kernSleep function with the provided arguments
<  * The result of the kernSleep function is stored back in the USLOSS_Sysargs structure
<  *
<  * Parameters:
<  *   sysargs - pointer to the USLOSS_Sysargs structure containing the system call arguments
<  *
<  * Returns:
<  *   void
<  */
< void sleepHandler(USLOSS_Sysargs *sysargs)
< {
<     int seconds = (int)(long)sysargs->arg1;
---
>     // Grab the characters from the mailbox
>     int charWrite = 0;
789c298,300
<     int res = kernSleep(seconds);
---
>     lock(TermWriteLocks[unit]);
>     int sysStat = Kernel_TermWrite(buff, buffSize, unit, &charWrite);
>     unlock(TermWriteLocks[unit]);
791c302,303
<     sysargs->arg4 = (void *)(long)res;
---
>     args->arg2 = (void *)(long)charWrite;
>     args->arg4 = (void *)(long)sysStat;
794,816d305
< /*
<  * Handles the clock device driver functionality
<  * It continuously waits for interrupts from the clock device
<  * Upon receiving an interrupt, it increments the clock_ticks counter
<  * and checks the sleep queue to wake up any processes whose sleep time has expired
<  * The function acquires and releases the sleep_lock to ensure thread safety
<  *
<  * Parameters:
<  *   arg - unused parameter, provided for consistency with other device driver functions
<  *
<  * Returns:
<  *   int - always returns 0
<  */
< int clockDeviceDriver(char *arg)
< {
<     int status;
<     while (1)
<     {
<         waitDevice(USLOSS_CLOCK_DEV, 0, &status);
< 
<         lock(sleep_lock);
<         clock_ticks++;
<         printf("Clock ticks: %d\n", clock_ticks);
818,828d306
<         // iterating through the sleep queue to wake up any processes whose time is up
<         while (sleepQueue != NULL && sleepQueue->wakeupTime <= clock_ticks)
<         {
<             SleepProc *toWake = sleepQueue;
<             printf("Waking up process %d\n", toWake->pid);
<             unblockProc(toWake->pid);
<             sleepQueue = sleepQueue->next;
<         }
< 
<         unlock(sleep_lock);
<     }
830c308,310
<     return 0;
---
> void Kernel_DiskRead(USLOSS_Sysargs *args) {
>     // make sure we are in kernel mode
>     // read with USLOSS_DeviceInput
833,865c313,316
< /*
<  * Puts the current process to sleep for the specified number of seconds
<  * It calculates the wake-up time based on the current clock ticks and the requested sleep duration
<  * The function creates a SleepProc structure to store the process information and adds it to the sleep queue
<  * It acquires and releases the sleep_lock to ensure thread safety
<  * The process is then blocked until it is woken up by the clock device driver
<  *
<  * Parameters:
<  *   seconds - the number of seconds the process should sleep
<  *
<  * Returns:
<  *   int - returns 0 on success, -1 if an invalid sleep duration is provided
<  */
< int kernSleep(int seconds)
< {
<     lock(sleep_lock);
< 
<     // invalid argument
<     if (seconds < 0)
<     {
<         return -1;
<     }
< 
<     int wakeup_tick = clock_ticks + (seconds * 10);
<     int cur_pid = getpid();
<     printf("Process %d going to sleep for %d seconds\n", cur_pid, seconds);
<     printf("Wakeup time: %d\n", wakeup_tick);
< 
<     // save data into struct
<     SleepProc *request = &sleepTable[cur_pid % MAXPROC];
<     request->pid = cur_pid;
<     request->wakeupTime = wakeup_tick;
<     request->next = NULL;
---
> void Kernel_DiskWrite(USLOSS_Sysargs *args) {
>     // make sure we are in kernel mode
>     // write with USLOSS_DeviceOutput
> }
867,870c318,323
<     // add struct to sleep queue
<     if (sleepQueue == NULL)
<     {
<         sleepQueue = request;
---
> void Kernel_DiskSize(USLOSS_Sysargs *args) {
>     // make sure we are in kernel mode
>     int unit = args->arg1;
>     if (unit < 0 || unit >= USLOSS_DISK_UNITS) {
>         args->arg4 = -1;
>         return;
872,873d324
<     else
<     {
875,892c326,337
<         // finds the next place to insert process in the sleep queue
<         SleepProc *prev = NULL;
<         SleepProc *current = sleepQueue;
<         while (current != NULL && current->wakeupTime <= request->wakeupTime)
<         {
<             prev = current;
<             current = current->next;
<         }
<         if (prev == NULL)
<         {
<             request->next = sleepQueue;
<             sleepQueue = request;
<         }
<         else
<         {
<             request->next = prev->next;
<             prev->next = request;
<         }
---
>     /*
>     USLOSS_DeviceRequest req;
>     req.opr = ;
>     req.reg1 = (void*)(long)blockInd
> 
>     int blockBytes;
>     int trackBlocks;
>     int diskTracks;
>     int result = USLOSS_DeviceRequest(USLOSS_DISK_DEV, unit, &blockBytes, &trackBlocks, &diskTracks);
>     if (result != USLOSS_DEV_OK) {
>         args->arg4 = -1;
>         return;
893a339,342
>     args->arg1 = blockBytes;
>     args->arg2 = trackBlocks;
>     args->arg3 = diskTracks;
>     args->arg4 = 0;*/
895,910d343
<     totalSleepingProcs++;
< 
<     unlock(sleep_lock);
<     blockMe();
< 
<     return 0;
< }
< 
< /**
<  * Locks a mailbox acting as a mutex.
<  *
<  * @param lockId The mailbox ID to be locked.
<  */
< void lock(int lockId)
< {
<     MboxSend(lockId, NULL, 0);
913,920c346,347
< /**
<  * Unlocks a mailbox acting as a mutex.
<  *
<  * @param lockId The mailbox ID to be unlocked.
<  */
< void unlock(int lockId)
< {
<     MboxRecv(lockId, NULL, 0);
---
> void lock(int lockId) {
>     MboxSend(sleepLock, NULL, 0);
921a349,351
> void unlock(int lockId) {
>     MboxRecv(sleepLock, NULL, 0);
> }
\ No newline at end of file
